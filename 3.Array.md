# **Array**
---

### 1. **Search and Sort Problems**
Array search and sorting problems are very common and often involve efficiently finding or sorting elements under certain conditions.

#### **a. Binary Search**
Binary search is used on sorted arrays. It works by repeatedly dividing the search space in half.

##### **Problem: Search a number in a sorted array**
- **Approach**: Check if the middle element of the current array is the target. If the target is smaller, search the left half; if larger, search the right half.
  
```python
def binary_search(arr, target):
    low, high = 0, len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1
```

#### **b. Merge Sort, Quick Sort**
Sorting problems involve arranging elements in ascending or descending order. Merge sort and quick sort are two common algorithms with different approaches.

##### **Problem: Sort an array using Merge Sort**
- **Approach**: Recursively divide the array into two halves, sort each half, and then merge the two sorted halves.

```python
def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        left_half = arr[:mid]
        right_half = arr[mid:]

        merge_sort(left_half)
        merge_sort(right_half)

        i = j = k = 0
        while i < len(left_half) and j < len(right_half):
            if left_half[i] < right_half[j]:
                arr[k] = left_half[i]
                i += 1
            else:
                arr[k] = right_half[j]
                j += 1
            k += 1

        while i < len(left_half):
            arr[k] = left_half[i]
            i += 1
            k += 1

        while j < len(right_half):
            arr[k] = right_half[j]
            j += 1
            k += 1
```

#### **c. Kth Largest/Smallest Element**
This problem involves finding the k-th largest or smallest element in an array.

##### **Problem: Find the Kth largest element in an unsorted array**
- **Approach**: Use a variation of Quick Select (partition-based approach) to get the kth largest element in O(n) time.

```python
def partition(arr, low, high):
    pivot = arr[high]
    i = low - 1
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1

def quick_select(arr, low, high, k):
    if low <= high:
        pivot_index = partition(arr, low, high)
        if pivot_index == len(arr) - k:
            return arr[pivot_index]
        elif pivot_index < len(arr) - k:
            return quick_select(arr, pivot_index + 1, high, k)
        else:
            return quick_select(arr, low, pivot_index - 1, k)

def find_kth_largest(arr, k):
    return quick_select(arr, 0, len(arr) - 1, k)
```

#### **d. Peak Element in Array**
Find an element that is greater than its neighbors.

##### **Problem: Find any peak element in an array**
- **Approach**: Use binary search to reduce the search space and find a peak in logarithmic time.

```python
def find_peak_element(arr):
    low, high = 0, len(arr) - 1
    while low < high:
        mid = (low + high) // 2
        if arr[mid] < arr[mid + 1]:
            low = mid + 1
        else:
            high = mid
    return low
```

---

### 2. **Subarray/Subset Problems**
Subarray and subset problems focus on specific sequences of the array. 

#### **a. Maximum Subarray (Kadaneâ€™s Algorithm)**
Kadane's algorithm helps find the subarray with the maximum sum.

##### **Problem: Find the subarray with the maximum sum**
- **Approach**: Traverse the array while maintaining a current subarray sum and updating the maximum subarray sum whenever a new maximum is found.

```python
def max_subarray_sum(arr):
    max_current = max_global = arr[0]
    for i in range(1, len(arr)):
        max_current = max(arr[i], max_current + arr[i])
        if max_current > max_global:
            max_global = max_current
    return max_global
```

#### **b. Subarray Sum Equals K**
Find the number of subarrays whose sum equals a given value `K`.

##### **Problem: Count subarrays with sum equal to K**
- **Approach**: Use a prefix sum and a hashmap to store sums that can be reused to calculate subarray sums in constant time.

```python
def subarray_sum(nums, k):
    count = 0
    current_sum = 0
    prefix_sums = {0: 1}

    for num in nums:
        current_sum += num
        if current_sum - k in prefix_sums:
            count += prefix_sums[current_sum - k]
        prefix_sums[current_sum] = prefix_sums.get(current_sum, 0) + 1

    return count
```

#### **c. Longest Subarray with Equal Number of 0s and 1s**
This problem asks to find the longest contiguous subarray with an equal number of 0s and 1s.

##### **Problem: Find the longest subarray with equal 0s and 1s**
- **Approach**: Treat 0 as -1 and use a prefix sum technique with a hashmap to track where the sum was last seen.

```python
def longest_subarray(nums):
    max_length = 0
    prefix_sum = 0
    indices = {0: -1}
    
    for i, num in enumerate(nums):
        prefix_sum += 1 if num == 1 else -1
        if prefix_sum in indices:
            max_length = max(max_length, i - indices[prefix_sum])
        else:
            indices[prefix_sum] = i
    
    return max_length
```

---

### 3. **Sliding Window**
Sliding window techniques are useful for problems where we need to keep track of a dynamic range of elements.

#### **a. Maximum/Minimum in Every Window of Size K**
Find the maximum (or minimum) element in every sliding window of size `K` in the array.

##### **Problem: Maximum in every window of size K**
- **Approach**: Use a deque to store indices of array elements in the current window and maintain the maximum in constant time.

```python
from collections import deque

def max_in_windows(arr, k):
    deq = deque()
    result = []
    
    for i in range(len(arr)):
        # Remove elements that are out of the current window
        if deq and deq[0] == i - k:
            deq.popleft()
        
        # Remove elements smaller than the current element
        while deq and arr[deq[-1]] <= arr[i]:
            deq.pop()
        
        deq.append(i)
        
        # Add the maximum of the current window to the result
        if i >= k - 1:
            result.append(arr[deq[0]])
    
    return result
```

---

Let's continue from where we left off and cover the remaining array problem variants along with their thinking approach and Python code.

---

### 4. **Prefix Sum**
Prefix sum is a common technique used to solve range sum queries efficiently or to compute the sum of subarrays.

#### **a. Range Sum Queries**
Compute the sum of elements between two given indices `i` and `j`.

##### **Problem: Range sum query in constant time after preprocessing**
- **Approach**: Use a prefix sum array, where each element stores the sum of elements from the start to the current index. The sum of elements between `i` and `j` is `prefix_sum[j] - prefix_sum[i-1]`.

```python
def prefix_sum_array(arr):
    prefix_sum = [0] * len(arr)
    prefix_sum[0] = arr[0]
    
    for i in range(1, len(arr)):
        prefix_sum[i] = prefix_sum[i - 1] + arr[i]
    
    return prefix_sum

def range_sum(prefix_sum, i, j):
    return prefix_sum[j] - (prefix_sum[i - 1] if i > 0 else 0)
```

#### **b. Subarray Sum Equals K**
This problem was discussed previously in section 2, where a prefix sum technique is used with a hashmap to count subarrays with a given sum.

---

### 5. **Two Pointer/Three Pointer Problems**
Two and three-pointer techniques are often used in problems that involve searching or sorting with multiple conditions.

#### **a. Merge Two Sorted Arrays**
Merge two sorted arrays into one sorted array.

##### **Problem: Merge two sorted arrays**
- **Approach**: Use two pointers, one for each array, to compare elements and build the result array.

```python
def merge_sorted_arrays(arr1, arr2):
    i, j = 0, 0
    result = []
    
    while i < len(arr1) and j < len(arr2):
        if arr1[i] < arr2[j]:
            result.append(arr1[i])
            i += 1
        else:
            result.append(arr2[j])
            j += 1
    
    result.extend(arr1[i:])
    result.extend(arr2[j:])
    
    return result
```

#### **b. Triplet Sum Equals Zero**
Find all unique triplets in the array that sum up to zero.

##### **Problem: Find triplets that sum to zero**
- **Approach**: First sort the array, then use the two-pointer technique for each element. Fix one element and use two pointers to find pairs that sum to the negative of the fixed element.

```python
def three_sum(arr):
    arr.sort()
    result = []
    
    for i in range(len(arr) - 2):
        if i > 0 and arr[i] == arr[i - 1]:
            continue
        left, right = i + 1, len(arr) - 1
        
        while left < right:
            total = arr[i] + arr[left] + arr[right]
            if total == 0:
                result.append([arr[i], arr[left], arr[right]])
                left += 1
                right -= 1
                while left < right and arr[left] == arr[left - 1]:
                    left += 1
                while left < right and arr[right] == arr[right + 1]:
                    right -= 1
            elif total < 0:
                left += 1
            else:
                right -= 1
    
    return result
```

#### **c. Dutch National Flag Problem**
This problem involves sorting an array of 0s, 1s, and 2s in-place with a three-pointer approach.

##### **Problem: Sort an array of 0s, 1s, and 2s**
- **Approach**: Use three pointers to track elements of the three categories (0s, 1s, and 2s) and rearrange the array in a single pass.

```python
def dutch_national_flag(arr):
    low, mid, high = 0, 0, len(arr) - 1
    
    while mid <= high:
        if arr[mid] == 0:
            arr[low], arr[mid] = arr[mid], arr[low]
            low += 1
            mid += 1
        elif arr[mid] == 1:
            mid += 1
        else:
            arr[mid], arr[high] = arr[high], arr[mid]
            high -= 1
```

---

### 6. **Matrix Problems (2D Arrays)**
2D arrays are often treated as matrices, and problems in this category revolve around manipulating rows and columns.

#### **a. Rotate Matrix by 90 Degrees**
Given an `n x n` matrix, rotate it by 90 degrees clockwise.

##### **Problem: Rotate the matrix by 90 degrees**
- **Approach**: First transpose the matrix (swap rows and columns), then reverse each row.

```python
def rotate_matrix(matrix):
    n = len(matrix)
    
    # Transpose the matrix
    for i in range(n):
        for j in range(i, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    
    # Reverse each row
    for i in range(n):
        matrix[i].reverse()
```

#### **b. Search in a Row-Wise and Column-Wise Sorted Matrix**
Find a target value in a matrix where each row and each column is sorted in ascending order.

##### **Problem: Search in a row-wise and column-wise sorted matrix**
- **Approach**: Start from the top-right corner. If the target is smaller, move left; if larger, move down.

```python
def search_matrix(matrix, target):
    if not matrix:
        return False
    
    row, col = 0, len(matrix[0]) - 1
    
    while row < len(matrix) and col >= 0:
        if matrix[row][col] == target:
            return True
        elif matrix[row][col] > target:
            col -= 1
        else:
            row += 1
    
    return False
```

#### **c. Spiral Order Matrix**
Print the elements of a matrix in spiral order.

##### **Problem: Print the matrix in spiral order**
- **Approach**: Simulate the process of moving right, down, left, and up in layers until all elements are covered.

```python
def spiral_order(matrix):
    result = []
    if not matrix:
        return result
    
    top, bottom = 0, len(matrix) - 1
    left, right = 0, len(matrix[0]) - 1
    
    while top <= bottom and left <= right:
        for i in range(left, right + 1):
            result.append(matrix[top][i])
        top += 1
        
        for i in range(top, bottom + 1):
            result.append(matrix[i][right])
        right -= 1
        
        if top <= bottom:
            for i in range(right, left - 1, -1):
                result.append(matrix[bottom][i])
            bottom -= 1
        
        if left <= right:
            for i in range(bottom, top - 1, -1):
                result.append(matrix[i][left])
            left += 1
    
    return result
```

---

### 7. **Greedy/Optimization Problems**
These problems require making the best local choice at each step to achieve a global solution.

#### **a. Trapping Rain Water**
Given an array representing the height of bars, calculate how much rainwater can be trapped between the bars.

##### **Problem: Calculate trapped rainwater**
- **Approach**: Use two pointers, one starting from the left and one from the right. At each step, move the pointer at the lower height and calculate water based on the difference between the current height and the maximum height encountered.

```python
def trap_water(heights):
    if not heights:
        return 0
    
    left, right = 0, len(heights) - 1
    left_max, right_max = heights[left], heights[right]
    water_trapped = 0
    
    while left < right:
        if heights[left] < heights[right]:
            left += 1
            left_max = max(left_max, heights[left])
            water_trapped += max(0, left_max - heights[left])
        else:
            right -= 1
            right_max = max(right_max, heights[right])
            water_trapped += max(0, right_max - heights[right])
    
    return water_trapped
```

#### **b. Buy and Sell Stock (Maximum Profit)**
Given an array of stock prices where the i-th element represents the price on day `i`, find the maximum profit that can be made by buying and selling one share of the stock.

##### **Problem: Find the maximum profit from buying and selling stock**
- **Approach**: Traverse the array while maintaining the minimum price encountered and calculate the profit for each day by subtracting the minimum price from the current price.

```python
def max_profit(prices):
    if not prices:
        return 0
    
    min_price = float('inf')
    max_profit = 0
    
    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)
    
    return max_profit
```

---

Let's continue with the remaining categories of array problems, their approaches, and the Python code.

---

### 8. **Greedy/Optimization Problems (continued)**

#### **c. Minimum Platforms Problem**
Given arrival and departure times of trains, determine the minimum number of platforms required for the station to accommodate the trains without any overlap.

##### **Problem: Minimum number of platforms required**
- **Approach**: Sort the arrival and departure times separately. Use two pointers to traverse both arrays, incrementing platform count when a train arrives and decrementing when a train departs.

```python
def min_platforms(arrivals, departures):
    arrivals.sort()
    departures.sort()
    
    platform_needed = 0
    max_platforms = 0
    i = j = 0
    
    while i < len(arrivals) and j < len(departures):
        if arrivals[i] <= departures[j]:
            platform_needed += 1
            i += 1
            max_platforms = max(max_platforms, platform_needed)
        else:
            platform_needed -= 1
            j += 1
    
    return max_platforms
```

#### **d. Gas Station Problem**
Given a circular route of gas stations, find if you can complete the circuit starting at any station.

##### **Problem: Complete a circular route with given gas stations**
- **Approach**: Track the total gas and the gas needed at each point. If at any point the gas becomes negative, reset the starting station to the next one.

```python
def can_complete_circuit(gas, cost):
    total_gas = total_cost = 0
    start = 0
    tank = 0
    
    for i in range(len(gas)):
        total_gas += gas[i]
        total_cost += cost[i]
        tank += gas[i] - cost[i]
        
        if tank < 0:
            start = i + 1
            tank = 0
    
    return start if total_gas >= total_cost else -1
```

---

### 9. **Miscellaneous Array Manipulations**

#### **a. Find Missing Number**
Given an array of size `n-1` with elements ranging from `1` to `n`, find the missing number.

##### **Problem: Find the missing number in an array of size `n-1`**
- **Approach**: Use the sum formula for the first `n` natural numbers and subtract the sum of the array to find the missing number.

```python
def find_missing(arr, n):
    total = n * (n + 1) // 2
    return total - sum(arr)
```

#### **b. Find Duplicate Number**
Given an array of `n + 1` integers where each integer is between `1` and `n`, find the duplicate number.

##### **Problem: Find the duplicate number**
- **Approach**: Use Floyd's Tortoise and Hare (Cycle Detection) algorithm to detect the cycle (duplicate) in the array.

```python
def find_duplicate(nums):
    slow = fast = nums[0]
    
    # Phase 1: Finding the intersection point
    while True:
        slow = nums[slow]
        fast = nums[nums[fast]]
        if slow == fast:
            break
    
    # Phase 2: Finding the entrance to the cycle
    slow = nums[0]
    while slow != fast:
        slow = nums[slow]
        fast = nums[fast]
    
    return slow
```

#### **c. Merge Intervals**
Given a set of intervals, merge overlapping intervals.

##### **Problem: Merge overlapping intervals**
- **Approach**: Sort intervals by their start time, then iterate through them while merging any overlapping intervals.

```python
def merge_intervals(intervals):
    if not intervals:
        return []
    
    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]
    
    for current in intervals[1:]:
        last_merged = merged[-1]
        if current[0] <= last_merged[1]:
            last_merged[1] = max(last_merged[1], current[1])
        else:
            merged.append(current)
    
    return merged
```

#### **d. Maximum Product Subarray**
Find the contiguous subarray within an array that has the largest product.

##### **Problem: Find the subarray with the maximum product**
- **Approach**: Keep track of the maximum and minimum products ending at the current position (since a negative number can flip the signs), and update the result with the maximum product encountered.

```python
def max_product_subarray(nums):
    if not nums:
        return 0
    
    max_product = min_product = result = nums[0]
    
    for num in nums[1:]:
        temp_max = max(num, max_product * num, min_product * num)
        min_product = min(num, max_product * num, min_product * num)
        max_product = temp_max
        result = max(result, max_product)
    
    return result
```

---

### 10. **Bit Manipulation in Arrays**

#### **a. Single Number**
Given an array of integers where every element appears twice except for one, find the single number.

##### **Problem: Find the single number in an array**
- **Approach**: Use XOR operation. XOR of a number with itself is 0, so all duplicate numbers will cancel out, leaving the single number.

```python
def single_number(nums):
    result = 0
    for num in nums:
        result ^= num
    return result
```

#### **b. Find Two Non-Repeating Numbers**
Given an array of integers where every element appears twice except for two, find the two numbers.

##### **Problem: Find two non-repeating numbers**
- **Approach**: First XOR all the elements to get `XOR = a ^ b`. Find the rightmost set bit in XOR, and partition the array into two groups based on that bit. XOR each group to get `a` and `b`.

```python
def find_two_non_repeating(nums):
    xor = 0
    for num in nums:
        xor ^= num
    
    # Get the rightmost set bit
    rightmost_set_bit = xor & -xor
    
    a, b = 0, 0
    for num in nums:
        if num & rightmost_set_bit:
            a ^= num
        else:
            b ^= num
    
    return a, b
```

---

### 11. **Segregation Problems**

#### **a. Segregate 0s and 1s**
Given a binary array, segregate 0s and 1s in linear time and constant space.

##### **Problem: Segregate 0s and 1s**
- **Approach**: Use two pointers to move 0s to the left and 1s to the right.

```python
def segregate_zeros_ones(arr):
    left, right = 0, len(arr) - 1
    
    while left < right:
        if arr[left] == 0:
            left += 1
        elif arr[right] == 1:
            right -= 1
        else:
            arr[left], arr[right] = arr[right], arr[left]
            left += 1
            right -= 1
```This completes the detailed walkthrough of the 25 major array problem categories and their variants. Each problem has its approach explained and includes Python code to help you implement and understand the solutions.

Feel free to ask about any specific problems or concepts that you'd like more clarification on!

#### **b. Move Zeros to End**
Given an array, move all the zeros to the end while maintaining the relative order of the non-zero elements.

##### **Problem: Move zeros to the end**
- **Approach**: Use two pointers to keep track of the current index and the index where the next non-zero element should be placed.

```python
def move_zeros(arr):
    insert_pos = 0
    
    for num in arr:
        if num != 0:
            arr[insert_pos] = num
            insert_pos += 1
    
    while insert_pos < len(arr):
        arr[insert_pos] = 0
        insert_pos += 1
```

---

### 12. **Matrix Manipulation (Advanced)**

#### **a. Set Matrix Zeroes**
Given an `m x n` matrix, if an element is 0, set its entire row and column to 0.

##### **Problem: Set entire row and column to 0 if an element is 0**
- **Approach**: Use the first row and first column of the matrix as markers. Traverse the matrix to mark which rows and columns should be zeroed.

```python
def set_matrix_zeroes(matrix):
    is_col = False
    rows, cols = len(matrix), len(matrix[0])
    
    for i in range(rows):
        if matrix[i][0] == 0:
            is_col = True
        for j in range(1, cols):
            if matrix[i][j] == 0:
                matrix[i][0] = matrix[0][j] = 0
    
    for i in range(1, rows):
        for j in range(1, cols):
            if matrix[i][0] == 0 or matrix[0][j] == 0:
                matrix[i][j] = 0
    
    if matrix[0][0] == 0:
        for j in range(cols):
            matrix[0][j] = 0
    
    if is_col:
        for i in range(rows):
            matrix[i][0] = 0
```

---

Apologies for the oversight earlier. Let's continue with the remaining categories of array problems, discussing the thinking approaches and providing Python code for each.

---

### 13. **Combination Sum and Subset Sum Variants**

These problems involve finding combinations or subsets within an array that meet certain criteria, such as summing to a target value.

#### **a. Subset Sum Problem**

Given a set of positive integers and a target sum, determine if there's a subset that sums up to the target.

##### **Problem: Determine if a subset sums to a target value**

- **Approach**: Use dynamic programming to build a boolean table `dp[i][j]` where `dp[i][j]` is `True` if a subset of the first `i` numbers sums up to `j`.

```python
def is_subset_sum(nums, target):
    n = len(nums)
    dp = [[False]*(target+1) for _ in range(n+1)]
    for i in range(n+1):
        dp[i][0] = True  # Empty subset sums to 0

    for i in range(1, n+1):
        for j in range(1, target+1):
            if nums[i-1] > j:
                dp[i][j] = dp[i-1][j]
            else:
                # Include or exclude the current number
                dp[i][j] = dp[i-1][j] or dp[i-1][j - nums[i-1]]

    return dp[n][target]
```

#### **b. Combination Sum**

Find all unique combinations of numbers that sum up to a target, where each number can be used unlimited times.

##### **Problem: Find combinations that sum to a target (numbers can be reused)**

- **Approach**: Use backtracking to explore all possible combinations. Sort the array to handle duplicates.

```python
def combination_sum(candidates, target):
    def backtrack(start, path, total):
        if total == target:
            result.append(list(path))
            return
        elif total > target:
            return
        for i in range(start, len(candidates)):
            path.append(candidates[i])
            backtrack(i, path, total + candidates[i])
            path.pop()
    
    candidates.sort()
    result = []
    backtrack(0, [], 0)
    return result
```

#### **c. Combination Sum II**

Similar to Combination Sum, but each number can be used only once.

##### **Problem: Find combinations that sum to a target (numbers can be used once)**

- **Approach**: Use backtracking and ensure that each combination is unique by skipping duplicates.

```python
def combination_sum2(candidates, target):
    def backtrack(start, path, total):
        if total == target:
            result.append(list(path))
            return
        elif total > target:
            return
        prev = -1
        for i in range(start, len(candidates)):
            if candidates[i] == prev:
                continue
            path.append(candidates[i])
            backtrack(i + 1, path, total + candidates[i])
            path.pop()
            prev = candidates[i]
    
    candidates.sort()
    result = []
    backtrack(0, [], 0)
    return result
```

---

### 14. **Rearrangement Problems**

These problems involve rearranging the elements of the array to satisfy certain conditions.

#### **a. Rearrange Array Alternately**

Given a sorted array, rearrange it in maximum-minimum form.

##### **Problem: Rearrange array in max-min form**

- **Approach**: Use an auxiliary array or modify the original array by encoding two elements at one index using modulo operations.

```python
def rearrange_max_min(arr):
    n = len(arr)
    max_idx = n - 1
    min_idx = 0
    max_elem = arr[-1] + 1  # Element greater than all elements in array

    for i in range(n):
        if i % 2 == 0:
            arr[i] += (arr[max_idx] % max_elem) * max_elem
            max_idx -= 1
        else:
            arr[i] += (arr[min_idx] % max_elem) * max_elem
            min_idx += 1

    for i in range(n):
        arr[i] = arr[i] // max_elem
```

#### **b. Rearrange Positive and Negative Numbers**

Rearrange the array so that positive and negative numbers alternate.

##### **Problem: Rearrange array with alternating positive and negative numbers**

- **Approach**: Use partitioning to separate positive and negative numbers, then merge them by alternating elements.

```python
def rearrange_alternate(nums):
    pos = [x for x in nums if x >= 0]
    neg = [x for x in nums if x < 0]
    nums.clear()
    i = j = 0
    while i < len(pos) and j < len(neg):
        nums.append(pos[i])
        nums.append(neg[j])
        i += 1
        j += 1
    nums.extend(pos[i:])
    nums.extend(neg[j:])
```

---

### 15. **Frequency Counting**

These problems involve finding elements that appear more than a certain number of times.

#### **a. Majority Element (Appearing More Than N/2 Times)**

Find the element that appears more than half the time.

##### **Problem: Find the majority element**

- **Approach**: Use Boyer-Moore Voting Algorithm to find the candidate.

```python
def majority_element(nums):
    count = 0
    candidate = None

    for num in nums:
        if count == 0:
            candidate = num
        count += (1 if num == candidate else -1)

    return candidate
```

#### **b. Elements Appearing More Than N/3 Times**

Find all elements appearing more than n/3 times.

##### **Problem: Find elements appearing more than n/3 times**

- **Approach**: Extended Boyer-Moore algorithm to handle up to two potential candidates.

```python
def majority_element_n_by_3(nums):
    if not nums:
        return []
    count1 = count2 = 0
    candidate1 = candidate2 = None

    for num in nums:
        if candidate1 == num:
            count1 += 1
        elif candidate2 == num:
            count2 +=1
        elif count1 == 0:
            candidate1 = num
            count1 =1
        elif count2 ==0:
            candidate2 = num
            count2 =1
        else:
            count1 -=1
            count2 -=1

    # Verify the candidates
    result = []
    for candidate in [candidate1, candidate2]:
        if nums.count(candidate) > len(nums) //3:
            result.append(candidate)
    return result
```

---

### 16. **Array Manipulation**

These problems involve performing operations on ranges or rearranging elements.

#### **a. Range Addition**

Increment elements in a given range by a value.

##### **Problem: Perform multiple range updates efficiently**

- **Approach**: Use a difference array to record the increments and calculate the final array.

```python
def range_addition(length, updates):
    arr = [0] * (length + 1)
    for start, end, val in updates:
        arr[start] += val
        if end + 1 < length:
            arr[end + 1] -= val

    # Compute the final array
    for i in range(1, length):
        arr[i] += arr[i - 1]

    return arr[:-1]
```

#### **b. Reverse Pairs**

Count the number of reverse pairs where `i < j` and `arr[i] > 2 * arr[j]`.

##### **Problem: Count reverse pairs**

- **Approach**: Use a modified merge sort to count the reverse pairs during the merge process.

```python
def reverse_pairs(nums):
    def merge_sort(nums):
        if len(nums) <= 1:
            return nums, 0
        mid = len(nums) // 2
        left, count_left = merge_sort(nums[:mid])
        right, count_right = merge_sort(nums[mid:])
        count = count_left + count_right

        # Count reverse pairs
        j = 0
        for i in range(len(left)):
            while j < len(right) and left[i] > 2 * right[j]:
                j += 1
            count += j

        # Merge step
        merged = []
        l = r = 0
        while l < len(left) and r < len(right):
            if left[l] <= right[r]:
                merged.append(left[l])
                l += 1
            else:
                merged.append(right[r])
                r += 1
        merged.extend(left[l:])
        merged.extend(right[r:])
        return merged, count

    _, total_count = merge_sort(nums)
    return total_count
```

---

### 17. **Array Transformations**

Transform the array according to specific rules.

#### **a. Next Permutation**

Rearrange numbers to the next lexicographically greater permutation.

##### **Problem: Find the next permutation**

- **Approach**: Find the first decreasing element from the end, swap it with the smallest element larger than it to the right, and reverse the remaining elements.

```python
def next_permutation(nums):
    n = len(nums)
    i = n - 2

    # Find the first decreasing element
    while i >=0 and nums[i] >= nums[i+1]:
        i -=1

    if i >= 0:
        j = n -1
        while nums[j] <= nums[i]:
            j -=1
        nums[i], nums[j] = nums[j], nums[i]

    # Reverse the rest
    nums[i+1:] = reversed(nums[i+1:])
```

#### **b. Transform Array by Replacing Each Element with the Greatest Element to its Right**

##### **Problem: Replace each element with the greatest element on its right**

- **Approach**: Traverse the array from the end, keeping track of the maximum element.

```python
def replace_elements(arr):
    max_from_right = -1
    for i in range(len(arr)-1, -1, -1):
        arr[i], max_from_right = max_from_right, max(arr[i], max_from_right)
    return arr
```

---

### 18. **Merging or Splitting Arrays**

Problems involving merging multiple arrays or splitting arrays based on conditions.

#### **a. Merge K Sorted Arrays**

Merge `k` sorted arrays into one sorted array.

##### **Problem: Merge k sorted arrays**

- **Approach**: Use a min-heap to efficiently get the smallest element among the arrays.

```python
import heapq

def merge_k_arrays(arrays):
    min_heap = []
    for i, array in enumerate(arrays):
        if array:
            heapq.heappush(min_heap, (array[0], i, 0))

    result = []
    while min_heap:
        val, list_idx, element_idx = heapq.heappop(min_heap)
        result.append(val)
        if element_idx +1 < len(arrays[list_idx]):
            next_tuple = (arrays[list_idx][element_idx+1], list_idx, element_idx+1)
            heapq.heappush(min_heap, next_tuple)
    return result
```

#### **b. Split Array into Consecutive Subsequences**

Split the array into subsequences of consecutive integers.

##### **Problem: Split array into consecutive subsequences**

- **Approach**: Use a hashmap to keep track of potential subsequences and greedily assign numbers to existing subsequences or start new ones.

```python
from collections import defaultdict

def is_possible(nums):
    freq = defaultdict(int)
    appendfreq = defaultdict(int)
    for num in nums:
        freq[num] += 1

    for num in nums:
        if freq[num] == 0:
            continue
        elif appendfreq[num] > 0:
            appendfreq[num] -= 1
            appendfreq[num +1] += 1
        elif freq[num +1] > 0 and freq[num +2] > 0:
            freq[num +1] -=1
            freq[num +2] -=1
            appendfreq[num +3] +=1
        else:
            return False
        freq[num] -=1
    return True
```

---

### 19. **Mathematical Operations on Arrays**

Perform mathematical computations on array elements.

#### **a. Maximum Product Subarray**

This was covered earlier in section 9.d.

#### **b. Maximum Sum Increasing Subsequence**

Find the maximum sum of an increasing subsequence.

##### **Problem: Maximum sum of increasing subsequence**

- **Approach**: Use dynamic programming to store the maximum sum up to each element.

```python
def max_sum_increasing_subsequence(nums):
    n = len(nums)
    dp = nums.copy()
    for i in range(1, n):
        for j in range(i):
            if nums[i] > nums[j] and dp[i] < dp[j] + nums[i]:
                dp[i] = dp[j] + nums[i]
    return max(dp)
```

---

### 20. **Circular Array**

Problems where the array is considered circular.

#### **a. Maximum Circular Subarray Sum**

Find the maximum sum of a subarray in a circular array.

##### **Problem: Maximum circular subarray sum**

- **Approach**: The maximum circular sum is either the maximum subarray sum (Kadane's algorithm) or the total sum minus the minimum subarray sum.

```python
def max_subarray_sum_circular(nums):
    def kadane(nums):
        max_current = max_global = nums[0]
        for num in nums[1:]:
            max_current = max(num, max_current + num)
            max_global = max(max_global, max_current)
        return max_global

    max_kadane = kadane(nums)
    total_sum = sum(nums)
    nums_inv = [-num for num in nums]
    max_wrap = total_sum + kadane(nums_inv)
    if max_wrap == 0:
        return max_kadane
    return max(max_kadane, max_wrap)
```

---

### 21. **Segmentation/Chunking Problems**

Divide the array into chunks based on certain conditions.

#### **a. Divide Array into Chunks**

Split the array into chunks where each chunk is sorted after sorting the entire array.

##### **Problem: Max chunks to make sorted**

- **Approach**: Keep track of the maximum value till the current index and compare it with the sorted array.

```python
def max_chunks_to_sorted(arr):
    max_so_far = 0
    chunks = 0
    for i, num in enumerate(arr):
        max_so_far = max(max_so_far, num)
        if max_so_far == i:
            chunks +=1
    return chunks
```

---

### 22. **Permutation and Combination Problems**

Generate all permutations or combinations.

#### **a. Find All Permutations of an Array**

Generate all possible permutations.

##### **Problem: Generate all permutations**

- **Approach**: Use backtracking to generate all permutations.

```python
def permute(nums):
    def backtrack(start):
        if start == len(nums):
            result.append(nums[:])
        for i in range(start, len(nums)):
            nums[start], nums[i] = nums[i], nums[start]
            backtrack(start +1)
            nums[start], nums[i] = nums[i], nums[start]
    
    result = []
    backtrack(0)
    return result
```

#### **b. Find All Subsequences of an Array**

Generate all subsequences (power set).

##### **Problem: Generate all subsequences**

- **Approach**: Use recursion to include or exclude each element.

```python
def subsequences(nums):
    def backtrack(index, path):
        if index == len(nums):
            result.append(path)
            return
        backtrack(index +1, path)
        backtrack(index +1, path + [nums[index]])

    result = []
    backtrack(0, [])
    return result
```

---

### 23. **Monotonic Arrays**

Arrays that are entirely non-increasing or non-decreasing.

#### **a. Check if Array is Monotonic**

Determine if the array is monotonic.

##### **Problem: Check if the array is monotonic**

- **Approach**: Check if the array is entirely non-increasing or non-decreasing.

```python
def is_monotonic(nums):
    increasing = decreasing = True
    for i in range(1, len(nums)):
        if nums[i] > nums[i -1]:
            decreasing = False
        if nums[i] < nums[i -1]:
            increasing = False
    return increasing or decreasing
```

---

### 24. **Stack-based Array Problems**

Utilize a stack to solve array problems.

#### **a. Nearest Greater to Left/Right**

Find the nearest greater element to the left/right for each element.

##### **Problem: Nearest greater to right**

- **Approach**: Use a stack to keep track of elements. Traverse from right to left for nearest greater to right.

```python
def nearest_greater_to_right(nums):
    stack = []
    result = [0]*len(nums)
    for i in range(len(nums)-1, -1, -1):
        while stack and stack[-1] <= nums[i]:
            stack.pop()
        result[i] = stack[-1] if stack else -1
        stack.append(nums[i])
    return result
```

---

### 25. **Miscellaneous Problems**

#### **a. Longest Consecutive Sequence**

Find the length of the longest consecutive elements sequence.

##### **Problem: Find longest consecutive sequence**

- **Approach**: Use a set for O(1) lookups and check for the start of a sequence.

```python
def longest_consecutive(nums):
    num_set = set(nums)
    longest_streak = 0
    for num in num_set:
        if num -1 not in num_set:
            current_num = num
            streak =1
            while current_num +1 in num_set:
                current_num +=1
                streak +=1
            longest_streak = max(longest_streak, streak)
    return longest_streak
```

#### **b. Count Inversions in an Array**

Count the number of inversions required to sort the array.

##### **Problem: Count inversions**

- **Approach**: Use a modified merge sort to count inversions.

```python
def count_inversions(arr):
    def merge_sort(arr):
        if len(arr) <=1:
            return arr, 0
        mid = len(arr) //2
        left, inv_left = merge_sort(arr[:mid])
        right, inv_right = merge_sort(arr[mid:])
        merged, inv_split = merge(left, right)
        total_inv = inv_left + inv_right + inv_split
        return merged, total_inv

    def merge(left, right):
        i = j = inv_count =0
        merged = []
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                merged.append(left[i])
                i +=1
            else:
                merged.append(right[j])
                inv_count += len(left) - i
                j +=1
        merged.extend(left[i:])
        merged.extend(right[j:])
        return merged, inv_count

    _, total_inv = merge_sort(arr)
    return total_inv
```

---

### 26. **Advanced Dynamic Programming Problems**

#### **a. Minimum Number of Swaps to Sort Array**

Find the minimum number of swaps required to sort the array.

##### **Problem: Minimum swaps to sort**

- **Approach**: Track visited elements and cycles in the array.

```python
def min_swaps_to_sort(nums):
    n = len(nums)
    arr_pos = list(enumerate(nums))
    arr_pos.sort(key=lambda it: it[1])
    visited = [False]*n
    swaps = 0
    for i in range(n):
        if visited[i] or arr_pos[i][0] == i:
            continue
        cycle_size = 0
        j = i
        while not visited[j]:
            visited[j] = True
            j = arr_pos[j][0]
            cycle_size +=1
        if cycle_size >1:
            swaps += cycle_size -1
    return swaps
```

---

